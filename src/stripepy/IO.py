# Copyright (C) 2024 Andrea Raffo <andrea.raffo@ibv.uio.no>
#
# SPDX-License-Identifier: MIT

import datetime
import functools
import json
import pathlib
import shutil
from importlib.metadata import version
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union

import h5py
import hictkpy
import numpy as np
import numpy.typing as npt
import pandas as pd

from stripepy.utils.stripe import Stripe


class Result(object):
    """
    A class used to represent the results generated by stripepy call.

    Attributes
    ----------
    chrom: Tuple[str, int]
        name and length of the chromosomes to which the Result instance belongs to
    empty: bool
        check whether any stripe has been registered with the Result instance
    roi: Optional[Dict[str, List[int]]]
        the region of interest associated with the Result instance
    min_persistence: float
        the minimum persistence used during computation
    """

    def __init__(self, chrom_name: str, chrom_size: int):
        """
        Parameters
        ----------

        chrom: str
            chromosome name
        """
        assert chrom_size > 0

        self._chrom = (chrom_name, chrom_size)
        self._roi = None
        self._min_persistence = None

        self._ut_all_minimum_points = None
        self._ut_all_maximum_points = None
        self._ut_persistence_of_all_minimum_points = None
        self._ut_persistence_of_all_maximum_points = None

        self._lt_all_minimum_points = None
        self._lt_all_maximum_points = None
        self._lt_persistence_of_all_minimum_points = None
        self._lt_persistence_of_all_maximum_points = None

        self._ut_persistent_minimum_points = None
        self._ut_persistent_maximum_points = None
        self._ut_persistence_of_minimum_points = None
        self._ut_persistence_of_maximum_points = None
        self._ut_pseudodistribution = None

        self._lt_persistent_minimum_points = None
        self._lt_persistent_maximum_points = None
        self._lt_persistence_of_minimum_points = None
        self._lt_persistence_of_maximum_points = None
        self._lt_pseudodistribution = None

        self._ut_stripes = None
        self._lt_stripes = None

    @property
    def _valid_attributes(self) -> List[str]:
        """
        Get the list of valid attributes
        """
        return [a.removeprefix("_lt_") for a in dir(self) if a.startswith("_lt_")]

    @property
    def empty(self) -> bool:
        return self._lt_stripes is None and self._ut_stripes is None

    @property
    def chrom(self) -> Tuple[str, int]:
        return self._chrom

    @property
    def roi(self) -> Optional[Dict[str, List[int]]]:
        return self._roi

    @property
    def min_persistence(self) -> float:
        if self._min_persistence is None:
            raise RuntimeError('Attribute "min_persistence" is not set')

        return self._min_persistence

    def get(self, name: str, location: str) -> Union[List[Stripe], npt.NDArray[int], npt.NDArray[float]]:
        """
        Get the value associated with the given attribute name and location.

        Parameters
        ----------
        name: str
            name of the attribute to be fetched
        location: str
            location of the attribute to be fetched. Should be "LT" or "UT"

        Returns
        -------
        attribute
            the value associated with the given name and location.
        """
        if location not in {"LT", "UT"}:
            raise ValueError("Location should be UT or LT")

        attr_name = f"_{location.lower()}_{name}"
        if not hasattr(self, attr_name):
            raise AttributeError(
                f"No attribute named \"{name}\". Valid attributes are: {', '.join(self._valid_attributes)}"
            )

        attr = getattr(self, attr_name)
        if name == "stripes" and attr is None:
            return []

        if attr is None:
            raise RuntimeError(f'Attribute "{name}" for "{location}" is not set')

        return attr

    def get_stripes_descriptor(self, descriptor: str, location: str) -> Union[npt.NDArray[float], npt.NDArray[int]]:
        """
        Get the stripe descriptor for the given location.

        Parameters
        ----------
        descriptor: str
            name of the descriptor to be fetched
        location: str
            location of the attribute to be fetched. Should be "LT" or "UT"

        Returns
        -------
        descriptor
            the value associated with the given descriptor and location.
        """
        if location not in {"LT", "UT"}:
            raise ValueError("Location should be UT or LT")

        if not hasattr(Stripe, descriptor):
            raise AttributeError(f'Stripe instance does not have an attribute named "{descriptor}"')

        stripes = self.get("stripes", location)

        if descriptor in {"seed", "left_bound", "right_bound", "top_bound", "bottom_bound"}:
            dtype = int
        else:
            dtype = float

        return np.array([getattr(stripe, descriptor) for stripe in stripes], dtype=dtype)

    def get_stripe_geo_descriptors(self, location: str) -> pd.DataFrame:
        """
        Fetch all geometric descriptors at once.

        Parameters
        ----------
        location: str
            location of the attribute to be fetched. Should be "LT" or "UT"

        Returns
        -------
        descriptors
            the table with the geometric descriptors associated with the Result instance
        """
        descriptors = [
            "seed",
            "top_persistence",
            "left_bound",
            "right_bound",
            "top_bound",
            "bottom_bound",
        ]

        return pd.DataFrame(
            {descriptor: self.get_stripes_descriptor(descriptor, location) for descriptor in descriptors}
        )

    def get_stripe_bio_descriptors(self, location: str) -> pd.DataFrame:
        """
        Fetch all biological descriptors at once.

        Parameters
        ----------
        location: str
            location of the attribute to be fetched. Should be "LT" or "UT"

        Returns
        -------
        descriptors
            the table with the biological descriptors associated with the Result instance
        """
        descriptors = [
            "inner_mean",
            "outer_mean",
            "rel_change",
            "inner_std",
        ]

        return pd.DataFrame(
            {descriptor: self.get_stripes_descriptor(descriptor, location) for descriptor in descriptors}
        )

    def set_roi(self, coords: Dict[str, List[int]]):
        """
        Set the region of interest (RoI) for the current Result instance.

        Parameters
        ----------
        coords: Dict[str, List[int]]
            a dictionary with the coordinates of the region of interest.
            The dictionary should contain two keys: "genomic" and "matrix".
            The value associated with the "genomic" key should be a list of 4 integers
            representing the genomic coordinates of the region of interest.
            The value associated with the "matrix" key should be a list of 4 integers
            representing the matrix coordinates of the region of interest.
        """
        if self._roi is not None:
            raise RuntimeError("roi has already been set")

        self._roi = coords

    def set_min_persistence(self, min_persistence: float):
        """
        Set the minimum persistence used during computation.

        Parameters
        ----------
        min_persistence: float
        """
        if self._min_persistence is not None:
            raise RuntimeError("min_persistence has already been set")

        self._min_persistence = min_persistence

    def set(self, name: str, data: Union[Sequence[int], Sequence[float], Sequence[Stripe]], location: str):
        """
        Set the attribute corresponding to the given attribute name and location.

        Parameters
        ----------
        name: str
           name of the attribute to be set.
           Supported attributes are:
              * all_minimum_points
              * all_maximum_points
              * persistence_of_all_minimum_points
              * persistence_of_all_maximum_points
              * persistent_minimum_points
              * persistent_maximum_points
              * persistence_of_minimum_points
              * persistence_of_maximum_points
              * pseudodistribution
              * stripes

        data:
            data to be registered with the Result instance
        location: str
            location of the attribute to be registered. Should be "LT" or "UT"
        """
        if location not in {"LT", "UT"}:
            raise ValueError("Location should be UT or LT")

        attr_name = f"_{location.lower()}_{name}"
        if not hasattr(self, attr_name):
            raise AttributeError(
                f"No attribute named \"{name}\". Valid attributes are: {', '.join(self._valid_attributes)}"
            )

        if getattr(self, attr_name) is not None:
            raise RuntimeError(f'Attribute "{name}" for {location} has already been set')

        setattr(self, attr_name, np.array(data))


class ResultFile(object):
    """
    A class used to read and write StripePy results to a HDF5 file.

    Attributes
    ----------
    path: pathlib.Path
        the path to the opened file
    assembly: str
        the name of the reference genome assembly used to generate the file
    resolution: int
        the resolution of the Hi-C matrix used to generate the file
    creation_date: datetime.datetime
        the file creation date
    format: str
        the file format string
    format_url: str
        the URL where the file format is documented
    format_version: int
        the format version of the file currently opened
    generated_by: str
        the name of the tool used to generate the opened file
    normalization: Optional[str]
        the name of the normalization used to generate the data stored in the given file
    chromosomes: Dict[str, int]
        the chromosomes associated with the opened file

    """

    def __init__(self, path: pathlib.Path, mode: str = "r"):
        if mode not in ["r", "w"]:
            raise ValueError('mode should be "r" or "w"')

        self._path = path
        self._mode = mode
        self._chroms = None

        self._h5 = h5py.File(self._path, self._mode)

        if self._mode == "r":
            self._validate(self._h5)
            self._chroms = {
                chrom.decode("utf-8"): size for chrom, size in zip(self._h5["/chroms/name"], self._h5["/chroms/length"])
            }

        self._version = self._h5.attrs.get("format-version", 1)
        self._attrs = dict(self._h5.attrs)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._h5.close()

    @property
    def path(self) -> pathlib.Path:
        return self._path

    @functools.cached_property
    def assembly(self) -> str:
        return self._h5.attrs["assembly"]

    @functools.cached_property
    def resolution(self) -> int:
        return int(self._h5.attrs["bin-size"])

    @functools.cached_property
    def creation_date(self) -> datetime.datetime:
        return datetime.datetime.fromisoformat(self._h5.attrs["creation-date"])

    @functools.cached_property
    def format(self) -> str:
        return self._h5.attrs["format"]

    @functools.cached_property
    def format_url(self) -> str:
        return self._h5.attrs["format-url"]

    @functools.cached_property
    def format_version(self) -> int:
        return self._h5.attrs["format-version"]

    @functools.cached_property
    def generated_by(self) -> str:
        return self._h5.attrs["generated-by"]

    @functools.cached_property
    def metadata(self) -> Dict[str, Any]:
        return json.loads(self._h5.attrs["metadata"])

    @functools.cached_property
    def normalization(self) -> Optional[str]:
        norm = self._h5.attrs["normalization"]
        if norm == "NONE":
            return None
        return norm

    @property
    def chromosomes(self) -> Dict[str, int]:
        return self._chroms

    @staticmethod
    def _validate(h5: h5py.File):
        """
        Perform a basic sanity check on the metadata of the current file
        """
        format = h5.attrs.get("format")  # noqa
        format_version = h5.attrs.get("format-version")
        try:
            if format is None:
                raise RuntimeError('attribute "format" is missing')

            if format_version is None:
                raise RuntimeError('attribute "format-version" is missing')

            if format != "HDF5::StripePy":
                raise RuntimeError(f'unrecognized file format: expected "HDF5::StripePy", found "{format}"')

            if format_version != 1:
                raise RuntimeError(
                    f'unsupported file format version "{format_version}". At present only version 1 is supported'
                )
        except RuntimeError as e:
            raise RuntimeError(
                f'failed to validate input file "{h5.filename}": {e}: file is corrupt or was not generated by StripePy.'
            )

    def get_min_persistence(self, chrom: str) -> float:
        """
        Get the minimum persistence associated with the given chromosome.

        Parameters
        ----------
        chrom: str
            chromosome name

        Returns
        -------
            the minimum persistence
        """
        if chrom not in self._chroms:
            raise KeyError(f'File "{self.path}" does not have data for chromosome "{chrom}"')

        return float(self._h5[f"/{chrom}/global-pseudo-distributions"].attrs["min_persistence_used"])

    def get(self, chrom: str, field: str, location: str) -> pd.DataFrame:
        """
        Get the data associated with the given chromosome, field, and location.

        Parameters
        ----------
        chrom: str
            chromosome name
        field: str
            name of the field to be fetched.
            Supported names:
                * pseudodistribution
                * all_minimum_points
                * persistence_of_all_minimum_points
                * all_maximum_points
                * persistence_of_all_maximum_points
                * geo_descriptors
                * bio_descriptors
        location: str
            location of the attribute to be registered. Should be "LT" or "UT"

        Returns
        -------
            the data associated with the given chromosome, field, and location
        """
        if chrom not in self._chroms:
            raise KeyError(f'File "{self.path}" does not have data for chromosome "{chrom}"')

        if location not in {"LT", "UT"}:
            raise ValueError("Location should be UT or LT")

        mappings = {
            "pseudodistribution": f"/{chrom}/global-pseudo-distributions/{location}/pseudo-distribution",
            "all_minimum_points": f"/{chrom}/global-pseudo-distributions/{location}/minima_pts_and_persistence",
            "persistence_of_all_minimum_points": f"/{chrom}/global-pseudo-distributions/{location}/minima_pts_and_persistence",
            "all_maximum_points": f"/{chrom}/global-pseudo-distributions/{location}/maxima_pts_and_persistence",
            "persistence_of_all_maximum_points": f"/{chrom}/global-pseudo-distributions/{location}/maxima_pts_and_persistence",
            "geo_descriptors": f"/{chrom}/stripes/{location}/geo-descriptors",
            "bio_descriptors": f"/{chrom}/stripes/{location}/bio-descriptors",
        }

        if field not in mappings:
            raise KeyError(f"Unknown field \"{field}\". Valid fields are {', '.join(mappings.keys())}")

        path = mappings[field]

        if field not in {"geo_descriptors", "bio_descriptors"}:
            data = self._h5[path][:]
            if field.startswith("persistence"):
                data = data[1, :]
            elif field.endswith("points"):
                data = data[0, :]
            return pd.DataFrame({field: data})

        df = pd.DataFrame(data=self._h5[path], columns=self._h5[path].attrs["col_names"])

        if field == "geo_descriptors":
            df = df.rename(
                columns={
                    "seed persistence": "top_persistence",
                    "L-boundary": "left_bound",
                    "R_boundary": "right_bound",
                    "U-boundary": "top_bound",
                    "D-boundary": "bottom_bound",
                }
            )
            for col in ("seed", "left_bound", "right_bound", "top_bound", "bottom_bound"):
                df[col] = df[col].astype(int)
            return df

        return df.rename(
            columns={
                "inner mean": "inner_mean",
                "outer mean": "outer_mean",
                "relative change": "rel_change",
                "standard deviation": "inner_std",
            }
        )

    def init_file(self, matrix_file: hictkpy.File, normalization: Optional[str], metadata: Dict[str, Any]):
        """
        Initialize the current file.

        This method must be called when opening a ResultFile for writing before adding data to the file.

        Parameters
        ----------
        matrix_file: hictkpy.File
            handle of the file that is used to compute the results stored in this file
        normalization: Optional[str]
            name of the normalization used to compute the results stored in this file
        metadata: Dict[str, Any]
            dictionary with the metadata to be associated with this file.
            The dictionary should contain values that can be encoded as a JSON string
        """
        if normalization is None:
            normalization = "NONE"

        self._chroms = matrix_file.chromosomes(include_ALL=False)

        self._h5.attrs["assembly"] = matrix_file.attributes().get("assembly", "unknown")
        self._h5.attrs["bin-size"] = matrix_file.resolution()
        self._h5.attrs["creation-date"] = datetime.datetime.now().isoformat()
        self._h5.attrs["format"] = "HDF5::StripePy"
        self._h5.attrs["format-url"] = "https://github.com/paulsengroup/StripePy"
        self._h5.attrs["format-version"] = 1
        self._h5.attrs["generated-by"] = f"StripePy v{version('stripepy-hic')}"
        self._h5.attrs["metadata"] = json.dumps(metadata, indent=2)
        self._h5.attrs["normalization"] = normalization

        chroms = matrix_file.chromosomes(include_ALL=False)
        self._h5.create_group("/chroms")
        self._h5.create_dataset("/chroms/name", data=list(chroms.keys()))
        self._h5.create_dataset("/chroms/length", data=list(chroms.values()))

    def write_descriptors(self, result: Result):
        """
        Read the descriptors from the given Result object and write them to the opened file.

        Parameters
        ----------
        result: Result
            results to be added to the opened file
        """
        chrom_name = result.chrom[0]
        grp = self._h5.create_group(f"/{chrom_name}/global-pseudo-distributions/")

        grp.attrs.create("min_persistence_used", result.min_persistence)

        for location in ["UT", "LT"]:
            grp = self._h5.create_group(f"/{chrom_name}/global-pseudo-distributions/{location}")
            grp.create_dataset(
                "pseudo-distribution",
                data=result.get("pseudodistribution", location),
                compression="gzip",
                compression_opts=4,
                shuffle=True,
            )
            grp.create_dataset(
                "minima_pts_and_persistence",
                data=np.array(
                    [
                        result.get("all_minimum_points", location),
                        result.get("persistence_of_all_minimum_points", location),
                    ]
                ),
                compression="gzip",
                compression_opts=4,
                shuffle=True,
            )
            grp.create_dataset(
                "maxima_pts_and_persistence",
                data=np.array(
                    [
                        result.get("all_maximum_points", location),
                        result.get("persistence_of_all_maximum_points", location),
                    ]
                ),
                compression="gzip",
                compression_opts=4,
                shuffle=True,
            )

            grp = self._h5.create_group(f"/{chrom_name}/stripes/{location}")
            descriptors = result.get_stripe_geo_descriptors(location)
            dset = grp.create_dataset(
                "geo-descriptors",
                data=descriptors.to_numpy(),
                compression="gzip",
                compression_opts=4,
                shuffle=True,
            )
            dset.attrs.create("col_names", data=descriptors.columns.tolist())

            descriptors = result.get_stripe_bio_descriptors(location)
            dset = grp.create_dataset(
                "bio-descriptors",
                data=descriptors.to_numpy(),
                compression="gzip",
                compression_opts=4,
                shuffle=True,
            )
            dset.attrs.create("col_names", data=descriptors.columns.tolist())


class ANSI:
    RED = "\033[31m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    MAGENTA = "\033[35m"
    CYAN = "\033[36m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"
    ENDC = "\033[0m"


def remove_and_create_folder(path: pathlib.Path, force: bool):
    path = pathlib.Path(path)

    # Deleting folders:
    if path.exists():
        if not force:
            raise RuntimeError(f"output folder {path} already exists. Pass --force to overwrite it.")
        else:
            shutil.rmtree(path)

    # Create the folder:
    path.mkdir(parents=True)


def create_folders_for_plots(path: pathlib.Path):
    path = pathlib.Path(path)

    folders4plots = [
        path,
        path / "1_preprocessing",
        path / "2_TDA",
        path / "3_shape_analysis",
        path / "4_biological_analysis",
        path / "3_shape_analysis" / "local_pseudodistributions",
    ]

    # Creating folders:
    for folder2create in folders4plots:
        folder2create.mkdir(parents=True)

    return folders4plots
